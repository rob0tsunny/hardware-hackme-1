# Hackme CPLD component

The CPLD is used for various hackme levels as a PIN/password verification device. The interface
is a UART running at 1Mbaud. The PIN/password is sent to the CPLD and the CPLD will reply with
either an ASCII 'Y' or 'N' depending on if the PIN/password was correct or not. The correct
PIN/password is hardcoded into the CPLD logic. The CPLD also expects an 8 MHz clock.

This code is optimized for minimal registers. Registers are the most limited resource in the
chosen 32-macrocell CPLD. Register usage has been carefully tracked. As coded, the code uses:
* txpath.v uses 7 registers (3-bit counter, 4-bit counter)
* rxpath.v uses 10 registers (3-bit counter, 4-bit counter, 3 DFFs)
* matcher.v uses 9 registers (6-bit counter, 2-bit FSM, 1 misc state bit)
The current compilation result manages to optimize out one of the matcher registers but adds two
buried combinatorial nodes to implement parts of the logic. This results in a total of 27 buried
nodes and three outputs (the UART TX wire and two debug outputs) for a total of 30 macrocells
used out of 32 .

## Code structure

The code hierarchy is as follows:

* cpld.v
    * matcher.v
    * rxpath.v
    * txpath.v

There are also some test harnesses that instantiates each of these modules and writes out a .lxt
waveform dump. The output is currently verified manually. Simulation is performed with
Icarus Verilog.

### txpath.v

This module is responsible for sending either a 'Y' or 'N' character. Transmission starts with a
1 on the `trigger` input. When transmission is complete, the `done` output will go high for one
clock cycle. `which_byte` selects whether a 'Y' or an 'N' will be output. If it is 0, a 'N' will
be output. Otherwise a 'Y' will be output. This signal must remain stable between asserting
`trigger` and before `done` goes high.

`cyc_counter` counts up continuously from 0 to 7. It is reset when `trigger` is activated. This
counter is used to obtain the data output rate of 1Mbaud from the 8 MHz input. It triggers
`bit_counter` when it counts up to 7 and overflows.

`bit_counter` is used to keep track of which data bit currently needs to be output. When it is 0,
it does not count. Otherwise, when `trigger` is activated, it is set to 1 and counts up every time
`cyc_counter` reaches 7. It resets to 0 after it reaches 10.

When `bit_counter` has a value in [1, 10] then the ASCII character will be output. The output
contains 1 start bit, 8 data bits, and 1 stop bit. The actual output signal is generated by a
large look-up-table case statement.

### rxpath.v

This module is responsible for controlling data reception. However, unlike a more typical UART
module, this does not contain a shift register to hold the received byte. This module only outputs
a signal `valid_now` that indicates when data on `out_bit` should be sampled. The `valid_now`
signal will go high a total of 8 times per byte. The `byte_start` signal will be high on the first
bit of every byte. These signals are then used to directly drive the matcher state machine. This
saves register space because the received byte does not have to be stored.

This module does not handle any errors at all (eg. invalid stop bit). It attempts to sample close
to the middle of each bit time. It only performs one sample per bit. There is also a known bug
with back-to-back bytes.

The input `rx_wire` is registered through 2 DFFs to prevent metastability. The resulting signal
is then passed through a third DFF to detect falling edges. This is used to detect start bits.

`cyc_counter` counts up continuously from 0 to 7. It is reset when a falling edge is detected
as long as a byte is not currently being received. This counter is used to obtain the data input
rate of 1Mbaud from the 8 MHz clock input. It triggers `bit_counter` when it counts up to 7 and
overflows.

`bit_counter` is used to keep track of which data bit currently needs to be input. When it is 0,
it does not count. Otherwise, when a falling edge is detected, it is set to 1 and counts up every
time `cyc_counter` reaches 7. It resets to 0 after it reaches 10.

The `valid_now` and `byte_start` signals are then generated combinatorially from the `cyc_counter`
and `bit_counter` counters.

### matcher.v

This module contains a counter and a small finite state machine that determines whether the
PIN/password are correct. Whether the 64-bit password or 16-bit PIN are used is controlled by
defining (or not defining) the `PATTERN_64` macro.

The initial state is `00`. While in this state, valid bits (from the
rxpath.v module) increment the `matcher_bit_cnt` counter. If any bits end up being incorrect,
`tx_which_byte` is set to 0 (it resets to 1). The FSM will stay in the `00` state until the
expected number of bits (16 or 64) are received. At that point, the FSM will go to the `10` state.
After one cycle, it will go into the `01` state. The `10` state causes a pulse that activates
txpath.v. In state `01`, the FSM will then wait for the txpath.v to activate the `done` signal.
At that point everything will be reset and the FSM will go back to state `00`.

## Building the code

Unfortunately, at this point in time the code can only be compiled with Xilinx ISE and not the
open-source tool flow. To build the code, add the Verilog files to a new ISE project.

ISE can be obtained from the Xilinx website [here](https://www.xilinx.com/products/design-tools/ise-design-suite.html).
You will need to create an account to download the tools. Use the final 14.7 version.

Ensure the synthesis settings are set as follows:
* -opt_mode: Area
* -opt_level: High
* -keep_hierarchy: No
* -fsm_encoding: User
* -resource_sharing: Enabled
* -iobuf: Enabled
* -equivalent_register_removal: Enabled
* -pld_ce: Enabled
* -pld_mp: Enabled
* -pld_xp: Enabled

Ensure the fitter settings are set as follows:
* -loc: Always
* -slew: Fast
* -init: Low
* -unused: Keeper
* -terminate: Keeper
* -iostd: LVCMOS33
* -optimize: Density
* -exhaust: Enabled
* -inputs: 40
* -pterms: 56
* -inreg: Enabled
* -blkfanin: 40

After compiling, you will get a .jed file. Use the open-source xc2bit tools to convert it to a
.crbit file. You will then need to *manually patch* the second-to-last row of the .crbit file
by replacing it with `01111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110`.
Finally, use the `crbit2bin.py` tool to convert that to a .bin file for embedding into the firmware.

## Steganography/"hidden" bits

TODO: This needs to be documented, but essentially the bits are manually patched in.
The ASCII phrase is patched into the .jed before conversion, and the "center" bits are patched in
the .crbit file.

## Simulating

Simulation is designed to work with Icarus Verilog. However, correct functionality is verified
manually rather than having the testbench check anything.

### txpath.v
1. `iverilog -o txpath_test txpath_test.v txpath.v`
2. `./txpath_test -lxt2`

The expected output is two characters 'N' and 'Y' transmitted on `tx_wire`.
Each bit of the transmitted output should be 8 cycles of `clk`. `done` should
go high after the stop bit after each byte.

### rxpath.v
1. `iverilog -o rxpath_test rxpath_test.v rxpath.v`
2. `./rxpath_test -lxt2`

The expected output is 8 pulses on `valid_now` for each byte (there are two bytes in the test).
The falling edge of the `valid_now` pulse should aligned with the middle of each bit on `out_bit`.
The first of each set of 8 pulses should have `byte_start` high, and the rest should have it low.

### matcher.v
1. `iverilog -DPATTERN_64 -o matcher_test matcher_test.v matcher.v`
2. `./matcher_test -lxt2`

The expected output is for a pulse on `tx_trigger` to occur after 64 pulses of `rx_bit_valid_now`.
The first pulse should coincide with `tx_which_byte` being high, and the second should coincide
with `tx_which_byte` being low. Expanding out the DUT signals, `matcher_bit_count` should count
from 0x00 to 0x3F as bits are received. `matcher_state` should stay 00 while receiving bits,
change to 10 after all bits are received (coinciding with the pulse on `tx_trigger`),
change to 01 after 1 clock, and then change back to 00 after another clock (because `tx_done` will
go high).

### cpld.v
1. `iverilog -DPATTERN_64 -o cpld_full_test cpld_full_test.v cpld.v matcher.v rxpath.v txpath.v`
2. `./cpld_full_test -lxt2`

The expected output on `tx_wire` is an ASCII 'Y' after the first group of bytes and an ASCII 'N'
after the second group of bytes. The bytes are only sent after receiving 8 bytes in both cases.
